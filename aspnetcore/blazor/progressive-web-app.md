---
title: ASP.NET Core Blazor WebAssembly を使用してプログレッシブ Web アプリケーションをビルドする
author: guardrex
description: Blazor ベースのプログレッシブ Web アプリケーション (PWA) をビルドする方法について説明します。これは、最新のブラウザー機能を使用してデスクトップ アプリのように動作する Web アプリです。
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083561"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a>ASP.NET Core Blazor WebAssembly を使用してプログレッシブ Web アプリケーションをビルドする

作成者: [Steve Sanderson](https://github.com/SteveSandersonMS)

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

プログレッシブ Web アプリケーション (PWA) は、最新のブラウザーの API と機能を使用してデスクトップ アプリケーションのように動作する Web ベースのアプリケーションです。 次のような機能があります。

* ネットワーク速度に関係なく、オフラインで作業し、常に瞬時に読み込まれる
* ブラウザー ウィンドウだけでなく、独自のアプリケーション ウィンドウで実行できる
* ホスト オペレーティング システム (OS) のスタート メニュー、ドッキング、またはホーム画面から起動する
* ユーザーがアプリケーションを使用していない場合でも、バックエンド サーバーからプッシュ通知を受信する
* バックグラウンドで自動更新される

ユーザーは、最初に他のシングルページ アプリケーション (SPA) と同様に Web ブラウザー内でアプリケーションを検出して使用し、その後、一歩進んで (プログレッシブに) OS にインストールしてプッシュ通知を有効にする場合があります。 そのため、*プログレッシブ*という用語が使用されます。

Blazor WebAssembly は、標準規格に準拠した真のクライアント側 Web アプリケーション プラットフォームであり、上記の機能に必要な PWA API を含む任意のブラウザー API を使用できます。 他のクライアント側 Web テクノロジと同様に、オフラインでも機能します。

## <a name="pwa-template"></a>PWA テンプレート

新しい Blazor WebAssembly アプリケーションを作成するときに、PWA 機能を追加するオプションが用意されています。 Visual Studio では、オプションはプロジェクト作成ダイアログのチェックボックスとして指定されています。

![イメージ](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

コマンド ラインでプロジェクトを作成する場合は、`--pwa` フラグを使用できます。 たとえば、オブジェクトに適用された

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

どちらの場合も、必要に応じてこれを [ASP.NET Core hosted]\(ASP.NET Core でホストされる\) オプションと組み合わせることができますが、必須ではありません。 PWA 機能は、ホスティング モデルに依存しません。

## <a name="installation-and-app-manifest"></a>インストールとアプリ マニフェスト

PWA テンプレート オプションを使用して作成されたアプリケーションにアクセスすると、ユーザーに対して、OS のスタート メニュー、ドッキング、またはホーム画面にアプリケーションをインストールするオプションが表示されます。

このオプションがどのように表示されるかは、ユーザーのブラウザーによって異なります。 たとえば、Edge や Chrome などのデスクトップ Chromium ベースのブラウザーを使用している場合、URL バーに *[追加]* ボタンが表示されます。

![イメージ](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

iOS では、Safari の *[共有]* ボタンとその *[ホーム画面に追加]* オプションを使用して、PWA をインストールできます。 Android 用の Chrome では、ユーザーは右上隅の *[メニュー]* ボタンをタップしてから、 *[ホーム画面に追加]* を選択する必要があります。

インストールが完了すると、アプリケーションはアドレス バーのない独自のウィンドウに表示されます。

![イメージ](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

ウィンドウのタイトル、配色、アイコン、またはその他の詳細をカスタマイズするには、プロジェクトの *wwwroot* ディレクトリにあるファイル `manifest.json` を参照してください。 このファイルのスキーマは、Web 標準によって定義されます。 詳細なドキュメントについては、 https://developer.mozilla.org/docs/Web/Manifest を参照してください。

## <a name="offline-support"></a>オフライン サポート

既定では、PWA テンプレート オプションを使用して作成されたアプリケーションでは、オフラインでの実行がサポートされています。 ユーザーは、最初にオンライン時にアプリケーションにアクセスする必要があります。その後、ブラウザーでは、オフラインでの操作に必要なすべてのリソースが自動的にダウンロードされてキャッシュされます。

> [!IMPORTANT]
> オフライン サポートは、*公開された*アプリケーションに対してのみ有効です。 開発時には有効になりません。 これは、変更とテストを行う通常の開発サイクルを妨げる可能性があるためです。

> [!WARNING]
> オフライン対応 PWA を出荷する予定の場合は、理解しておく必要がある[重要な警告と注意事項](#caveats-for-offline-pwas)がいくつかあります。 これらはオフラインの PWA に固有のものであり、Blazor に固有のものではありません。 オフライン対応アプリケーションがどのように動作するかを想定する前に、これらの注意事項を読んで理解しておいてください。

オフライン サポートがどのように機能するかを確認するには、まず[アプリケーションを公開](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)し、HTTPS をサポートするサーバーでホストします。 アプリケーションにアクセスすると、ブラウザーの開発ツールを開き、*サービス ワーカー*がホストに登録されていることを確認できます。

![イメージ](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

また、ページを再度読み込む場合は、 *[ネットワーク]* タブに、ページの読み込みに必要なすべてのリソースが*サービス ワーカー*または*メモリ キャッシュ*から取得されることが示されます。

![イメージ](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

これは、アプリケーションを読み込むためにブラウザーがネットワーク アクセスに依存していないことを示しています。 これを確認するには、Web サーバーをシャットダウンするか、オフライン モードをシミュレートするようにブラウザーを設定します。

![イメージ](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

これで、Web サーバーにアクセスできなくても、ページを再度読み込んで、アプリケーションが引き続き読み込まれて実行されていることを確認できます。 同様に、非常に低速のネットワーク接続をシミュレートしても、ページはネットワークとは別に読み込まれるため、やはりすぐに読み込まれます。

### <a name="service-worker"></a>サービス ワーカー

オフライン サポートは、サービス ワーカーを使用して実現されます。 これは Web 標準であり、Blazor に固有ではありません。 サービス ワーカーに関するドキュメントについては、 https://developer.mozilla.org/docs/Web/API/Service_Worker_API を参照してください。 サービス ワーカーの一般的な使用パターンの詳細については、「[Service Worker のライフサイクル](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)」を参照してください。

Blazor の PWA テンプレートでは、次の 2 つのサービス ワーカー ファイルが生成されます。

* *wwwroot/service-worker.js*: 開発時に使用されます。
* *wwwroot/service-worker.published.js*: アプリケーションが公開された後に使用されます。

これらの 2 つのファイル間でロジックを共有する場合は、共通のロジックを保持する 3 つ目の JavaScript ファイルを追加し、[`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) を使用して、そのロジックを両方のファイルに読み込むことを検討してください。

#### <a name="cache-first-fetch-strategy"></a>キャッシュ優先のフェッチ戦略

組み込みの *service-worker.published.js* サービス ワーカーでは、*キャッシュ優先*戦略を使用して要求が解決されます。 これは、ユーザーがネットワークにアクセスできるかどうか、またはサーバーで使用可能な新しいコンテンツがあるかどうかに関係なく、キャッシュされたコンテンツがある場合は常にそれを返すことを意味します。

この方法が重要である理由は 2 つあります。

* **信頼性が確保されます。** ネットワーク アクセスはブール型ではありません。 ユーザーは単純に "オンライン" または "オフライン" なわけではありません。 現実的には、ユーザーのデバイスによってオンラインと見なされていても、ネットワークの速度が遅すぎるため、待機するのが現実的ではない場合があります。 または、ネットワークが特定の URL に対して無効な結果を返す場合があります。たとえば、特定の要求を現在ブロックまたはリダイレクトしている固定 WIFI ポータルがある場合などです。 このように、ブラウザーの `navigator.onLine` API は信頼できないため、依存しないようにする必要があります。
* **正確性が保証されます。** オフライン リソースのキャッシュを構築する場合、サービス ワーカーではコンテンツ ハッシュを使用して、リソースの完全かつ自己整合スナップショットが一度にフェッチされることが保証されます。 このキャッシュはアトミック ユニットとして使用されます。 したがって、必要な唯一のバージョンが既にキャッシュされているので、ネットワークに新しいリソースを要求する必要はありません。 その他のすべてのバージョンには、不整合と非互換性のリスクがあります (たとえば、一緒にコンパイルされていない .NET アセンブリのバージョンを使用しようとした場合など)。

#### <a name="background-updates"></a>バックグラウンド更新

メンタル モデルとして、オフラインファーストの PWA は、インストール可能なモバイル アプリのように動作すると考えることができます。 これはネットワーク接続に関係なく、常にすぐに起動しますが、インストールされているアプリケーション ロジックは、最新バージョンではない可能性がある特定の時点のスナップショットから取得されます。

Blazor PWA テンプレートを使用すると、ユーザーがアクセスしてネットワークに接続するたびに、バックグラウンドで自動的に自己更新を試行するアプリケーションが生成されます。 このしくみは次のとおりです。

* コンパイル中に、プロジェクトによって*サービス ワーカー アセット マニフェスト*が生成されます。 既定では、この名前は *service-worker-assets.js* です。 これには、アプリケーションがオフラインで機能するために必要なすべての静的リソース (.NET アセンブリ、JavaScript ファイル、CSS など) が、そのコンテンツ ハッシュと共にリストされています。 このリストは、キャッシュするリソースを認識できるように、サービス ワーカーによって読み込まれます。
* ユーザーがアプリケーションにアクセスするたびに、ブラウザーによって *service-worker.js* と *service-worker-assets.js* がバックグラウンドで再要求されます。 サーバーがこれらのファイルのいずれかについて変更されたコンテンツ (インストールされている既存のサービス ワーカーとバイト レベルで比較されます) を返した場合、サービス ワーカーではそれ自体の新しいバージョンのインストールが試行されます。
* サービス ワーカー自体の新しいバージョンがインストールされると、サービス ワーカーによってオフライン リソース用に新しい別のキャッシュが作成され、*service-worker-assets.js* にリストされたリソースがそのキャッシュに追加されます。 このロジックは、*service-worker.published.js* 内の `onInstall` 関数に実装されています。
* プロセスが正常に完了した場合 (つまり、すべてのリソースがエラーなしで読み込まれ、すべてのコンテンツ ハッシュが一致した場合)、新しいサービス ワーカーは "アクティブ化の待機中" 状態になります。 ユーザーがアプリケーションを終了する (つまり、アプリケーションを表示するタブやウィンドウが残っていない) とすぐに、新しいサービス ワーカーが "アクティブ" になり、その後のアプリケーションへのアクセスに使用されます。 古いサービス ワーカーとそのキャッシュは削除されます。
* プロセスが正常に完了しなかった場合、新しいサービス ワーカー インスタンスは破棄されます。 ユーザーが次にアクセスすると (このとき、要求を完了できるほどネットワーク接続が良好であることが望ましい)、更新プロセスがもう一度試行されます。

このプロセスの側面をカスタマイズするには、サービス ワーカー ロジックを編集します。 上記のいずれも Blazor に固有のものではなく、PWA テンプレート オプションによって提供される提案にすぎません。 詳細については、[サービス ワーカーのドキュメント](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.)を参照してください。

#### <a name="how-requests-are-resolved"></a>要求の解決方法

前述のように、既定のサービス ワーカーでは*キャッシュ優先*戦略が使用されます。これは、キャッシュされたコンテンツがあればそれが提供されることを意味します。 特定の URL に対してキャッシュされたコンテンツがない場合 (バックエンド API からデータを要求する場合など)、サービス ワーカーは通常のネットワーク要求に戻ります。このような要求は、サーバーが到達可能な場合にのみ成功します。 このロジックは、*service-worker.published.js* 内の `onFetch` 内に実装されています。

Blazor コンポーネントがバックエンド API からのデータの要求に依存しており、ネットワークが使用できないことが原因でこのような要求が失敗した場合にわかりやすいユーザー エクスペリエンスを提供するには、コンポーネント内にロジックを実装する必要があります。 たとえば、`HttpClient` 要求について `try/catch` を使用します。

#### <a name="support-server-rendered-pages"></a>サーバーでレンダリングされるページのサポート

ユーザーが最初に `/counter` などの URL、またはアプリケーションへのその他のディープ リンクに移動すると、どうなるでしょうか。 このような場合は、`/counter` としてキャッシュされたコンテンツを返すのではなく、`/index.html` としてキャッシュされたコンテンツをブラウザーで読み込み、Blazor WebAssembly アプリケーションを起動する必要があります。 これらの最初の要求は、*ナビゲーション*要求と呼ばれます (イメージや CSS などに対する*サブリソース*要求、または API データに対する*フェッチまたは XHR* 要求とは異なります)。

既定のサービス ワーカーには、ナビゲーション要求用の特殊なケースのロジックが含まれています。 これにより、要求された URL に関係なく、`/index.html` のキャッシュされたコンテンツを返すことで要求が解決されます。 このロジックは、*service-worker.published.js* 内の `onFetch` 関数に実装されています。

サーバーでレンダリングされた HTML を返す (キャッシュからの `/index.html` を提供するのではなく) 必要がある特定の URL がアプリケーションにある場合は、サービス ワーカーのロジックを編集する必要があります。 たとえば、`/Identity/` を含むすべての URL を、サーバーに対する通常のオンライン専用の要求として処理する必要がある場合、*service-worker.published.js* `onFetch` ロジックを変更します。 次のコードを見つけます。

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

コードを次のように変更します。

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

この変更を行わないと、ネットワーク接続に関係なく、サービス ワーカーによってこのような URL に対する要求がインターセプトされ、`/index.html` を使用してそれらが解決されます。

#### <a name="control-asset-caching"></a>アセット キャッシュの制御

プロジェクトで `ServiceWorkerAssetsManifest` という名前の MSBuild プロパティが定義されている場合は、Blazor のビルド ツールによって、指定された名前のサービス ワーカー アセット マニフェストが生成されます。 既定の PWA テンプレートでは、次を含むプロジェクト ファイルが生成されます。

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

ファイルは *wwwroot* 出力ディレクトリに配置されるため、ブラウザーでは `/service-worker-assets.js` を要求することによってこのファイルを取得できます。 コンテンツを表示するには、テキスト エディターで *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* を開きます。 ただし、ファイルは各ビルドで再生成されるため、編集しないでください。

既定では、このマニフェストには次の項目がリストされています。

* .NET アセンブリや .NET WebAssembly アセンブリ ランタイム ファイルなど、オフラインで機能するために必要な、Blazor 管理対象リソース
* イメージ、CSS ファイル、JavaScript ファイルなど、*wwwroot* ディレクトリに公開されるすべてのリソース。 これには、外部プロジェクトおよび NuGet パッケージによって提供される静的な Web アセットが含まれます。

サービス ワーカーによってフェッチおよびキャッシュされるリソースを制御するには、*service-worker.published.js* 内の `onInstall` のロジックを編集します。 既定では、 *.html*、 *.css*、 *.js*、 *.wasm* などの一般的な Web ファイル名の拡張子に一致するファイルのほか、Blazor WebAssembly に固有の種類のファイル ( *.dll*、 *.pdb*) がフェッチおよびキャッシュされます。

*wwwroot* ディレクトリに存在しない追加のリソースを含める場合は、追加の MSBuild ItemGroup エントリを定義します。 たとえば、プロジェクト ファイルに次のように追加します。

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

`AssetUrl` メタデータにより、ブラウザーでキャッシュするリソースをフェッチするときに使用されるベース相対 URL が指定されます。 これは、ディスク上の元のソース ファイル名に依存しないものにすることができます。

> [!IMPORTANT]
> `ServiceWorkerAssetsManifestItem` を追加しても、ファイルは *wwwroot* ディレクトリに公開されません。 公開の出力を個別に制御するかどうかは、開発者次第です。 `ServiceWorkerAssetsManifestItem` では、サービス ワーカー アセット マニフェストに追加のエントリが表示されるだけです。

## <a name="push-notifications"></a>プッシュ通知

他の PWA と同様に、Blazor WebAssembly PWA では、バックエンド サーバーからプッシュ通知を受信できます。 サーバーでは、ユーザーがアプリケーションをアクティブに使用していない場合 (たとえば、別のユーザーが、関連する可能性のある操作を実行する場合) でも、これらの通知をいつでも送信できます。

プッシュ通知を送信するメカニズムは、任意のテクノロジを使用できるバックエンド サーバーによって実装されているため、Blazor WebAssembly から完全に独立しています。 ASP.NET Core サーバーからプッシュ通知を送信する場合は、[Blazing Pizza ワークショップと同様の手法を使用する](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)ことを検討してください。

クライアントでプッシュ通知を受信して表示するメカニズムは、サービス ワーカー (JavaScript ファイル) に実装されているため、Blazor WebAssembly にも依存しません。 例として、[Blazing Pizza ワークショップで使用されている方法](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)をもう一度ご覧ください。

## <a name="caveats-for-offline-pwas"></a>オフラインの PWA に関する注意事項

すべてのアプリケーションでオフラインでの使用をサポートする必要はありません。 オフライン サポートは非常に複雑ですが、常に関連性があるとは限りません。

オフライン サポートは通常、次の場合にのみ関連性を持ちます。

* プライマリ データ ストアがブラウザーに対してローカルである場合。 たとえば、`localStorage` または [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API) にデータを格納する [IoT](https://en.wikipedia.org/wiki/Internet_of_things) デバイス用の UI をビルドする場合などです。

* ユーザーがオフラインで操作できるように、各ユーザーに関連するバックエンド API データをフェッチしてキャッシュする重要な作業を実行する場合。 編集をサポートする場合は、変更を追跡してバックエンドと同期するためのシステムも構築する必要があります。

* ネットワークの状態に関係なく、アプリケーションがすぐに読み込まれることを保証することを目標とする場合。 その場合、要求の進行状況を表示し、ネットワークが使用できないことが原因で失敗した場合は適切に動作する、バックエンド API 要求に関する適切なユーザー エクスペリエンスを実装する必要があります。

さらに、オフライン対応の PWA では、さまざまな複雑さに対処する必要があります。 開発者は、次の注意点をよく理解しておく必要があります。

### <a name="offline-support-only-when-published"></a>オフライン サポートは公開された場合のみ

Blazor の PWA テンプレートを使用すると、公開された場合にのみオフライン サポートが有効になります。 通常、開発時には、バックグラウンド更新プロセスを実行せずに、各変更がブラウザーにすぐに反映されることを確認したいからです。

そのため、オフライン対応アプリケーションをビルドする場合、開発モードでアプリケーションをテストするだけでは不十分です。 アプリケーションがさまざまなネットワークの状態にどのように応答するかを理解するには、アプリケーションが公開された状態でテストする必要があります。

### <a name="update-completion-after-user-navigation-away-from-app"></a>ユーザーがアプリから移動した後に更新が完了する

ユーザーがすべてのタブでアプリケーションから移動するまで、更新は完了しません。 「[バックグラウンド更新](#background-updates)」で説明されているように、アプリケーションに更新プログラムを配置すると、更新されたサービス ワーカー ファイルがブラウザーによってフェッチされ、更新プロセスが開始されます。

多くの開発者は、この更新が完了しても、ユーザーがすべてのタブでアプリケーションから移動しない限り、この更新が有効に**ならない**ことを意外に思うでしょう。 アプリケーションを 1 つのタブのみに表示している場合でも、アプリケーションを表示しているタブを更新するだけでは十分では**ありません**。 アプリケーションが完全に閉じられるまで、新しいサービス ワーカーは "アクティブ化の待機中" 状態のままになります。 **これは Blazor に固有のものではなく、標準的な Web プラットフォームの動作です。**

これは、サービス ワーカーまたはオフラインでキャッシュされたリソースに対する更新をテストしようとしている開発者にとって、共通の問題となります。 ブラウザーの開発ツールをチェックインすると、次のような内容が表示されることがあります。

![イメージ](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

"クライアント" (つまり、アプリケーションを表示しているタブまたはウィンドウ) のリストが空でない場合、ワーカーは待機を続けます。 サービス ワーカーが待機するのは、整合性を保証するためです。つまり、すべてのリソースが同じアトミック キャッシュからフェッチされます。

変更をテストする際には、上記のスクリーンショットに示されている "skipWaiting" リンクをクリックし、ページを再度読み込むと便利な場合があります。 必要に応じて、すべてのユーザーに対してこの動作を自動化できます。そのためには、"待機中" のフェーズをスキップして、[更新時にすぐにアクティブ化](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)するように、サービス ワーカーをコーディングします。 ただし、これを行うと、リソースが常に同じキャッシュ インスタンスから一貫してフェッチされることを保証できなくなります。

### <a name="users-may-run-any-historical-version-of-the-app"></a>ユーザーはアプリのあらゆる履歴バージョンを実行する可能性がある

Web 開発者は、ユーザーが、配置された最新バージョンの Web アプリケーションを実行するものと思いがちです。これは、従来の Web 配布モデルでは自然なことでした。 ただし、オフラインファーストの PWA は、ユーザーが必ずしも最新バージョンを実行しているとは限らないネイティブ モバイル アプリに似ています。

「[バックグラウンド更新](#background-updates)」で説明されているように、アプリケーションに更新プログラムを配置すると、**既存の各ユーザーは、少なくともあと 1 回のアクセスで以前のバージョンを使用し続けます** (更新がバックグラウンドで行われ、ユーザーがアプリケーションから移動するまでアクティブ化されないためです)。 また、前回使用されていたバージョンが必ずしも前回に配置したものとは限りません。ユーザーが最後に更新を完了した日時に応じて、*あらゆる*履歴バージョンが使用される可能性があります。

これは、アプリケーションのフロントエンドとバックエンドの部分が API 要求のスキーマに関する合意を必要とする場合に問題になることがあります。 すべてのユーザーがアップグレードされたことを確認できるまで、または少なくともユーザーが互換性のない古いバージョンのアプリを使用できないようにするまで、下位互換性のない API スキーマの変更を配置することはできません。 これは、ネイティブ モバイル アプリの場合と同じです。 サーバー API に重大な変更を配置すると、まだ更新されていないユーザーに対してクライアント アプリが中断されます。

可能であれば、バックエンド API に重大な変更を配置しないでください。 ただし、この配置を行う必要がある場合は、[`ServiceWorkerRegistration` などの標準のサービス ワーカー API](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) を使用して、アプリケーションが最新であるかどうかを判断し、最新でない場合は使用できないようにすることをお勧めします。

### <a name="interference-with-server-rendered-pages"></a>サーバーでレンダリングされるページによる干渉

[前述のように](#support-server-rendered-pages)、すべてのナビゲーション要求に対して `/index.html` コンテンツを返すサービス ワーカーの動作をバイパスする場合は、サービス ワーカーのロジックを編集する必要があります。

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a>サービス ワーカー アセット マニフェストのすべてのコンテンツが既定でキャッシュされる

[前述のように](#control-asset-caching)、ファイル *service-worker-assets.js* はビルド時に生成され、サービス ワーカーでフェッチおよびキャッシュする必要があるすべてのアセットがリストされています。

既定では、このリストには *wwwroot* に出力されるすべての項目 (外部のパッケージとプロジェクトによって提供されるコンテンツを含む) が含まれるので、コンテンツの数が多くなりすぎないように注意する必要があります。 たとえば、*wwwroot* ディレクトリに数百万のイメージが含まれている場合、サービス ワーカーによってそれらすべてのフェッチおよびキャッシュが試行され、過剰な帯域幅が消費されて、正常に完了しない可能性が高くなります。

*service-worker.published.js* 内の `onInstall` 関数を編集することで、マニフェストのコンテンツのどのサブセットをフェッチおよびキャッシュするかを制御するために任意のロジックを実装できます。

### <a name="interaction-with-authentication"></a>認証との相互作用

PWA テンプレート オプションを認証オプションと組み合わせて使用することもできます。 オフライン対応 PWA では、ユーザーがネットワークに接続しているときに認証をサポートすることもできます。

ただし、ユーザーがネットワークに接続されていない場合、アクセス トークンを認証したり取得したりすることはできません。 既定では、"ログイン" ページにアクセスしようとすると、"ネットワーク エラー" を示すメッセージが表示されます。

したがって、ユーザーがアクセス トークンを認証または取得しなくても、オフライン中に有用な作業を実行できるように、または、少なくともこのような場合に適切な形で失敗するように、開発者は UI フローを設計する必要があります。 アプリケーションでこれが不可能な場合は、オフライン サポートを有効にしないことをお勧めします。
