---
title: ASP.NET Core Blazor WebAssembly を使用してプログレッシブ Web アプリケーションをビルドする
author: guardrex
description: Blazor ベースのプログレッシブ Web アプリケーション (PWA) をビルドする方法について説明します。これは、最新のブラウザー機能を使用してデスクトップ アプリのように動作する Web アプリです。
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083561"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="9adb5-103">ASP.NET Core Blazor WebAssembly を使用してプログレッシブ Web アプリケーションをビルドする</span><span class="sxs-lookup"><span data-stu-id="9adb5-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="9adb5-104">作成者: [Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="9adb5-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="9adb5-105">プログレッシブ Web アプリケーション (PWA) は、最新のブラウザーの API と機能を使用してデスクトップ アプリケーションのように動作する Web ベースのアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="9adb5-106">次のような機能があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-106">These capabilities can include:</span></span>

* <span data-ttu-id="9adb5-107">ネットワーク速度に関係なく、オフラインで作業し、常に瞬時に読み込まれる</span><span class="sxs-lookup"><span data-stu-id="9adb5-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="9adb5-108">ブラウザー ウィンドウだけでなく、独自のアプリケーション ウィンドウで実行できる</span><span class="sxs-lookup"><span data-stu-id="9adb5-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="9adb5-109">ホスト オペレーティング システム (OS) のスタート メニュー、ドッキング、またはホーム画面から起動する</span><span class="sxs-lookup"><span data-stu-id="9adb5-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="9adb5-110">ユーザーがアプリケーションを使用していない場合でも、バックエンド サーバーからプッシュ通知を受信する</span><span class="sxs-lookup"><span data-stu-id="9adb5-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="9adb5-111">バックグラウンドで自動更新される</span><span class="sxs-lookup"><span data-stu-id="9adb5-111">Automatically updating in the background</span></span>

<span data-ttu-id="9adb5-112">ユーザーは、最初に他のシングルページ アプリケーション (SPA) と同様に Web ブラウザー内でアプリケーションを検出して使用し、その後、一歩進んで (プログレッシブに) OS にインストールしてプッシュ通知を有効にする場合があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="9adb5-113">そのため、*プログレッシブ*という用語が使用されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="9adb5-114"> WebAssembly は、標準規格に準拠した真のクライアント側 Web アプリケーション プラットフォームであり、上記の機能に必要な PWA API を含む任意のブラウザー API を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="9adb5-115">他のクライアント側 Web テクノロジと同様に、オフラインでも機能します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="9adb5-116">PWA テンプレート</span><span class="sxs-lookup"><span data-stu-id="9adb5-116">PWA template</span></span>

<span data-ttu-id="9adb5-117">新しい Blazor WebAssembly アプリケーションを作成するときに、PWA 機能を追加するオプションが用意されています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="9adb5-118">Visual Studio では、オプションはプロジェクト作成ダイアログのチェックボックスとして指定されています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="9adb5-120">コマンド ラインでプロジェクトを作成する場合は、`--pwa` フラグを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="9adb5-121">たとえば、オブジェクトに適用された</span><span class="sxs-lookup"><span data-stu-id="9adb5-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="9adb5-122">どちらの場合も、必要に応じてこれを [ASP.NET Core hosted]\(ASP.NET Core でホストされる\) オプションと組み合わせることができますが、必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="9adb5-123">PWA 機能は、ホスティング モデルに依存しません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="9adb5-124">インストールとアプリ マニフェスト</span><span class="sxs-lookup"><span data-stu-id="9adb5-124">Installation and app manifest</span></span>

<span data-ttu-id="9adb5-125">PWA テンプレート オプションを使用して作成されたアプリケーションにアクセスすると、ユーザーに対して、OS のスタート メニュー、ドッキング、またはホーム画面にアプリケーションをインストールするオプションが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="9adb5-126">このオプションがどのように表示されるかは、ユーザーのブラウザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="9adb5-127">たとえば、Edge や Chrome などのデスクトップ Chromium ベースのブラウザーを使用している場合、URL バーに *[追加]* ボタンが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="9adb5-129">iOS では、Safari の *[共有]* ボタンとその *[ホーム画面に追加]* オプションを使用して、PWA をインストールできます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="9adb5-130">Android 用の Chrome では、ユーザーは右上隅の *[メニュー]* ボタンをタップしてから、 *[ホーム画面に追加]* を選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="9adb5-131">インストールが完了すると、アプリケーションはアドレス バーのない独自のウィンドウに表示されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="9adb5-133">ウィンドウのタイトル、配色、アイコン、またはその他の詳細をカスタマイズするには、プロジェクトの *wwwroot* ディレクトリにあるファイル `manifest.json` を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="9adb5-134">このファイルのスキーマは、Web 標準によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="9adb5-135">詳細なドキュメントについては、 https://developer.mozilla.org/docs/Web/Manifest を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="9adb5-136">オフライン サポート</span><span class="sxs-lookup"><span data-stu-id="9adb5-136">Offline support</span></span>

<span data-ttu-id="9adb5-137">既定では、PWA テンプレート オプションを使用して作成されたアプリケーションでは、オフラインでの実行がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="9adb5-138">ユーザーは、最初にオンライン時にアプリケーションにアクセスする必要があります。その後、ブラウザーでは、オフラインでの操作に必要なすべてのリソースが自動的にダウンロードされてキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9adb5-139">オフライン サポートは、*公開された*アプリケーションに対してのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="9adb5-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="9adb5-140">開発時には有効になりません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-140">It is not enabled during development.</span></span> <span data-ttu-id="9adb5-141">これは、変更とテストを行う通常の開発サイクルを妨げる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="9adb5-142">オフライン対応 PWA を出荷する予定の場合は、理解しておく必要がある[重要な警告と注意事項](#caveats-for-offline-pwas)がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="9adb5-143">これらはオフラインの PWA に固有のものであり、Blazor に固有のものではありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="9adb5-144">オフライン対応アプリケーションがどのように動作するかを想定する前に、これらの注意事項を読んで理解しておいてください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="9adb5-145">オフライン サポートがどのように機能するかを確認するには、まず[アプリケーションを公開](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)し、HTTPS をサポートするサーバーでホストします。</span><span class="sxs-lookup"><span data-stu-id="9adb5-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="9adb5-146">アプリケーションにアクセスすると、ブラウザーの開発ツールを開き、*サービス ワーカー*がホストに登録されていることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="9adb5-148">また、ページを再度読み込む場合は、 *[ネットワーク]* タブに、ページの読み込みに必要なすべてのリソースが*サービス ワーカー*または*メモリ キャッシュ*から取得されることが示されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="9adb5-150">これは、アプリケーションを読み込むためにブラウザーがネットワーク アクセスに依存していないことを示しています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="9adb5-151">これを確認するには、Web サーバーをシャットダウンするか、オフライン モードをシミュレートするようにブラウザーを設定します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="9adb5-153">これで、Web サーバーにアクセスできなくても、ページを再度読み込んで、アプリケーションが引き続き読み込まれて実行されていることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="9adb5-154">同様に、非常に低速のネットワーク接続をシミュレートしても、ページはネットワークとは別に読み込まれるため、やはりすぐに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="9adb5-155">サービス ワーカー</span><span class="sxs-lookup"><span data-stu-id="9adb5-155">Service worker</span></span>

<span data-ttu-id="9adb5-156">オフライン サポートは、サービス ワーカーを使用して実現されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="9adb5-157">これは Web 標準であり、Blazor に固有ではありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="9adb5-158">サービス ワーカーに関するドキュメントについては、 https://developer.mozilla.org/docs/Web/API/Service_Worker_API を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="9adb5-159">サービス ワーカーの一般的な使用パターンの詳細については、「[Service Worker のライフサイクル](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="9adb5-160"> の PWA テンプレートでは、次の 2 つのサービス ワーカー ファイルが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-160">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="9adb5-161">*wwwroot/service-worker.js*: 開発時に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="9adb5-162">*wwwroot/service-worker.published.js*: アプリケーションが公開された後に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="9adb5-163">これらの 2 つのファイル間でロジックを共有する場合は、共通のロジックを保持する 3 つ目の JavaScript ファイルを追加し、[`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) を使用して、そのロジックを両方のファイルに読み込むことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="9adb5-164">キャッシュ優先のフェッチ戦略</span><span class="sxs-lookup"><span data-stu-id="9adb5-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="9adb5-165">組み込みの *service-worker.published.js* サービス ワーカーでは、*キャッシュ優先*戦略を使用して要求が解決されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="9adb5-166">これは、ユーザーがネットワークにアクセスできるかどうか、またはサーバーで使用可能な新しいコンテンツがあるかどうかに関係なく、キャッシュされたコンテンツがある場合は常にそれを返すことを意味します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="9adb5-167">この方法が重要である理由は 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="9adb5-168">**信頼性が確保されます。**</span><span class="sxs-lookup"><span data-stu-id="9adb5-168">**It ensures reliability.**</span></span> <span data-ttu-id="9adb5-169">ネットワーク アクセスはブール型ではありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-169">Network access is not a boolean state.</span></span> <span data-ttu-id="9adb5-170">ユーザーは単純に "オンライン" または "オフライン" なわけではありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="9adb5-171">現実的には、ユーザーのデバイスによってオンラインと見なされていても、ネットワークの速度が遅すぎるため、待機するのが現実的ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="9adb5-172">または、ネットワークが特定の URL に対して無効な結果を返す場合があります。たとえば、特定の要求を現在ブロックまたはリダイレクトしている固定 WIFI ポータルがある場合などです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="9adb5-173">このように、ブラウザーの `navigator.onLine` API は信頼できないため、依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="9adb5-174">**正確性が保証されます。**</span><span class="sxs-lookup"><span data-stu-id="9adb5-174">**It ensures correctness.**</span></span> <span data-ttu-id="9adb5-175">オフライン リソースのキャッシュを構築する場合、サービス ワーカーではコンテンツ ハッシュを使用して、リソースの完全かつ自己整合スナップショットが一度にフェッチされることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="9adb5-176">このキャッシュはアトミック ユニットとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="9adb5-177">したがって、必要な唯一のバージョンが既にキャッシュされているので、ネットワークに新しいリソースを要求する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="9adb5-178">その他のすべてのバージョンには、不整合と非互換性のリスクがあります (たとえば、一緒にコンパイルされていない .NET アセンブリのバージョンを使用しようとした場合など)。</span><span class="sxs-lookup"><span data-stu-id="9adb5-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="9adb5-179">バックグラウンド更新</span><span class="sxs-lookup"><span data-stu-id="9adb5-179">Background updates</span></span>

<span data-ttu-id="9adb5-180">メンタル モデルとして、オフラインファーストの PWA は、インストール可能なモバイル アプリのように動作すると考えることができます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="9adb5-181">これはネットワーク接続に関係なく、常にすぐに起動しますが、インストールされているアプリケーション ロジックは、最新バージョンではない可能性がある特定の時点のスナップショットから取得されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="9adb5-182">Blazor PWA テンプレートを使用すると、ユーザーがアクセスしてネットワークに接続するたびに、バックグラウンドで自動的に自己更新を試行するアプリケーションが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="9adb5-183">このしくみは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-183">The way this works is as follows:</span></span>

* <span data-ttu-id="9adb5-184">コンパイル中に、プロジェクトによって*サービス ワーカー アセット マニフェスト*が生成されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="9adb5-185">既定では、この名前は *service-worker-assets.js* です。</span><span class="sxs-lookup"><span data-stu-id="9adb5-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="9adb5-186">これには、アプリケーションがオフラインで機能するために必要なすべての静的リソース (.NET アセンブリ、JavaScript ファイル、CSS など) が、そのコンテンツ ハッシュと共にリストされています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="9adb5-187">このリストは、キャッシュするリソースを認識できるように、サービス ワーカーによって読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="9adb5-188">ユーザーがアプリケーションにアクセスするたびに、ブラウザーによって *service-worker.js* と *service-worker-assets.js* がバックグラウンドで再要求されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="9adb5-189">サーバーがこれらのファイルのいずれかについて変更されたコンテンツ (インストールされている既存のサービス ワーカーとバイト レベルで比較されます) を返した場合、サービス ワーカーではそれ自体の新しいバージョンのインストールが試行されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="9adb5-190">サービス ワーカー自体の新しいバージョンがインストールされると、サービス ワーカーによってオフライン リソース用に新しい別のキャッシュが作成され、*service-worker-assets.js* にリストされたリソースがそのキャッシュに追加されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="9adb5-191">このロジックは、*service-worker.published.js* 内の `onInstall` 関数に実装されています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="9adb5-192">プロセスが正常に完了した場合 (つまり、すべてのリソースがエラーなしで読み込まれ、すべてのコンテンツ ハッシュが一致した場合)、新しいサービス ワーカーは "アクティブ化の待機中" 状態になります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="9adb5-193">ユーザーがアプリケーションを終了する (つまり、アプリケーションを表示するタブやウィンドウが残っていない) とすぐに、新しいサービス ワーカーが "アクティブ" になり、その後のアプリケーションへのアクセスに使用されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="9adb5-194">古いサービス ワーカーとそのキャッシュは削除されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="9adb5-195">プロセスが正常に完了しなかった場合、新しいサービス ワーカー インスタンスは破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="9adb5-196">ユーザーが次にアクセスすると (このとき、要求を完了できるほどネットワーク接続が良好であることが望ましい)、更新プロセスがもう一度試行されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="9adb5-197">このプロセスの側面をカスタマイズするには、サービス ワーカー ロジックを編集します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="9adb5-198">上記のいずれも Blazor に固有のものではなく、PWA テンプレート オプションによって提供される提案にすぎません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="9adb5-199">詳細については、[サービス ワーカーのドキュメント](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="9adb5-200">要求の解決方法</span><span class="sxs-lookup"><span data-stu-id="9adb5-200">How requests are resolved</span></span>

<span data-ttu-id="9adb5-201">前述のように、既定のサービス ワーカーでは*キャッシュ優先*戦略が使用されます。これは、キャッシュされたコンテンツがあればそれが提供されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="9adb5-202">特定の URL に対してキャッシュされたコンテンツがない場合 (バックエンド API からデータを要求する場合など)、サービス ワーカーは通常のネットワーク要求に戻ります。このような要求は、サーバーが到達可能な場合にのみ成功します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="9adb5-203">このロジックは、*service-worker.published.js* 内の `onFetch` 内に実装されています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="9adb5-204">Blazor コンポーネントがバックエンド API からのデータの要求に依存しており、ネットワークが使用できないことが原因でこのような要求が失敗した場合にわかりやすいユーザー エクスペリエンスを提供するには、コンポーネント内にロジックを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="9adb5-205">たとえば、`HttpClient` 要求について `try/catch` を使用します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="9adb5-206">サーバーでレンダリングされるページのサポート</span><span class="sxs-lookup"><span data-stu-id="9adb5-206">Support server-rendered pages</span></span>

<span data-ttu-id="9adb5-207">ユーザーが最初に `/counter` などの URL、またはアプリケーションへのその他のディープ リンクに移動すると、どうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="9adb5-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="9adb5-208">このような場合は、`/counter` としてキャッシュされたコンテンツを返すのではなく、`/index.html` としてキャッシュされたコンテンツをブラウザーで読み込み、Blazor WebAssembly アプリケーションを起動する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="9adb5-209">これらの最初の要求は、*ナビゲーション*要求と呼ばれます (イメージや CSS などに対する*サブリソース*要求、または API データに対する*フェッチまたは XHR* 要求とは異なります)。</span><span class="sxs-lookup"><span data-stu-id="9adb5-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="9adb5-210">既定のサービス ワーカーには、ナビゲーション要求用の特殊なケースのロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="9adb5-211">これにより、要求された URL に関係なく、`/index.html` のキャッシュされたコンテンツを返すことで要求が解決されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="9adb5-212">このロジックは、*service-worker.published.js* 内の `onFetch` 関数に実装されています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="9adb5-213">サーバーでレンダリングされた HTML を返す (キャッシュからの `/index.html` を提供するのではなく) 必要がある特定の URL がアプリケーションにある場合は、サービス ワーカーのロジックを編集する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="9adb5-214">たとえば、`/Identity/` を含むすべての URL を、サーバーに対する通常のオンライン専用の要求として処理する必要がある場合、*service-worker.published.js* `onFetch` ロジックを変更します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="9adb5-215">次のコードを見つけます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="9adb5-216">コードを次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="9adb5-217">この変更を行わないと、ネットワーク接続に関係なく、サービス ワーカーによってこのような URL に対する要求がインターセプトされ、`/index.html` を使用してそれらが解決されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="9adb5-218">アセット キャッシュの制御</span><span class="sxs-lookup"><span data-stu-id="9adb5-218">Control asset caching</span></span>

<span data-ttu-id="9adb5-219">プロジェクトで `ServiceWorkerAssetsManifest` という名前の MSBuild プロパティが定義されている場合は、Blazor のビルド ツールによって、指定された名前のサービス ワーカー アセット マニフェストが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="9adb5-220">既定の PWA テンプレートでは、次を含むプロジェクト ファイルが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="9adb5-221">ファイルは *wwwroot* 出力ディレクトリに配置されるため、ブラウザーでは `/service-worker-assets.js` を要求することによってこのファイルを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="9adb5-222">コンテンツを表示するには、テキスト エディターで *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* を開きます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="9adb5-223">ただし、ファイルは各ビルドで再生成されるため、編集しないでください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="9adb5-224">既定では、このマニフェストには次の項目がリストされています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="9adb5-225">.NET アセンブリや .NET WebAssembly アセンブリ ランタイム ファイルなど、オフラインで機能するために必要な、Blazor 管理対象リソース</span><span class="sxs-lookup"><span data-stu-id="9adb5-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="9adb5-226">イメージ、CSS ファイル、JavaScript ファイルなど、*wwwroot* ディレクトリに公開されるすべてのリソース。</span><span class="sxs-lookup"><span data-stu-id="9adb5-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="9adb5-227">これには、外部プロジェクトおよび NuGet パッケージによって提供される静的な Web アセットが含まれます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="9adb5-228">サービス ワーカーによってフェッチおよびキャッシュされるリソースを制御するには、*service-worker.published.js* 内の `onInstall` のロジックを編集します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="9adb5-229">既定では、 *.html*、 *.css*、 *.js*、 *.wasm* などの一般的な Web ファイル名の拡張子に一致するファイルのほか、Blazor WebAssembly に固有の種類のファイル ( *.dll*、 *.pdb*) がフェッチおよびキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="9adb5-230">*wwwroot* ディレクトリに存在しない追加のリソースを含める場合は、追加の MSBuild ItemGroup エントリを定義します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="9adb5-231">たとえば、プロジェクト ファイルに次のように追加します。</span><span class="sxs-lookup"><span data-stu-id="9adb5-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="9adb5-232">`AssetUrl` メタデータにより、ブラウザーでキャッシュするリソースをフェッチするときに使用されるベース相対 URL が指定されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="9adb5-233">これは、ディスク上の元のソース ファイル名に依存しないものにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9adb5-234">`ServiceWorkerAssetsManifestItem` を追加しても、ファイルは *wwwroot* ディレクトリに公開されません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="9adb5-235">公開の出力を個別に制御するかどうかは、開発者次第です。</span><span class="sxs-lookup"><span data-stu-id="9adb5-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="9adb5-236">`ServiceWorkerAssetsManifestItem` では、サービス ワーカー アセット マニフェストに追加のエントリが表示されるだけです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="9adb5-237">プッシュ通知</span><span class="sxs-lookup"><span data-stu-id="9adb5-237">Push notifications</span></span>

<span data-ttu-id="9adb5-238">他の PWA と同様に、Blazor WebAssembly PWA では、バックエンド サーバーからプッシュ通知を受信できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="9adb5-239">サーバーでは、ユーザーがアプリケーションをアクティブに使用していない場合 (たとえば、別のユーザーが、関連する可能性のある操作を実行する場合) でも、これらの通知をいつでも送信できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="9adb5-240">プッシュ通知を送信するメカニズムは、任意のテクノロジを使用できるバックエンド サーバーによって実装されているため、Blazor WebAssembly から完全に独立しています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="9adb5-241">ASP.NET Core サーバーからプッシュ通知を送信する場合は、[Blazing Pizza ワークショップと同様の手法を使用する](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)ことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="9adb5-242">クライアントでプッシュ通知を受信して表示するメカニズムは、サービス ワーカー (JavaScript ファイル) に実装されているため、Blazor WebAssembly にも依存しません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="9adb5-243">例として、[Blazing Pizza ワークショップで使用されている方法](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)をもう一度ご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="9adb5-244">オフラインの PWA に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="9adb5-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="9adb5-245">すべてのアプリケーションでオフラインでの使用をサポートする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="9adb5-246">オフライン サポートは非常に複雑ですが、常に関連性があるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="9adb5-247">オフライン サポートは通常、次の場合にのみ関連性を持ちます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="9adb5-248">プライマリ データ ストアがブラウザーに対してローカルである場合。</span><span class="sxs-lookup"><span data-stu-id="9adb5-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="9adb5-249">たとえば、`localStorage` または [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API) にデータを格納する [IoT](https://en.wikipedia.org/wiki/Internet_of_things) デバイス用の UI をビルドする場合などです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="9adb5-250">ユーザーがオフラインで操作できるように、各ユーザーに関連するバックエンド API データをフェッチしてキャッシュする重要な作業を実行する場合。</span><span class="sxs-lookup"><span data-stu-id="9adb5-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="9adb5-251">編集をサポートする場合は、変更を追跡してバックエンドと同期するためのシステムも構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="9adb5-252">ネットワークの状態に関係なく、アプリケーションがすぐに読み込まれることを保証することを目標とする場合。</span><span class="sxs-lookup"><span data-stu-id="9adb5-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="9adb5-253">その場合、要求の進行状況を表示し、ネットワークが使用できないことが原因で失敗した場合は適切に動作する、バックエンド API 要求に関する適切なユーザー エクスペリエンスを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="9adb5-254">さらに、オフライン対応の PWA では、さまざまな複雑さに対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="9adb5-255">開発者は、次の注意点をよく理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="9adb5-256">オフライン サポートは公開された場合のみ</span><span class="sxs-lookup"><span data-stu-id="9adb5-256">Offline support only when published</span></span>

Blazor<span data-ttu-id="9adb5-257"> の PWA テンプレートを使用すると、公開された場合にのみオフライン サポートが有効になります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-257">'s PWA template enables offline support only when published.</span></span> <span data-ttu-id="9adb5-258">通常、開発時には、バックグラウンド更新プロセスを実行せずに、各変更がブラウザーにすぐに反映されることを確認したいからです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="9adb5-259">そのため、オフライン対応アプリケーションをビルドする場合、開発モードでアプリケーションをテストするだけでは不十分です。</span><span class="sxs-lookup"><span data-stu-id="9adb5-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="9adb5-260">アプリケーションがさまざまなネットワークの状態にどのように応答するかを理解するには、アプリケーションが公開された状態でテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="9adb5-261">ユーザーがアプリから移動した後に更新が完了する</span><span class="sxs-lookup"><span data-stu-id="9adb5-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="9adb5-262">ユーザーがすべてのタブでアプリケーションから移動するまで、更新は完了しません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="9adb5-263">「[バックグラウンド更新](#background-updates)」で説明されているように、アプリケーションに更新プログラムを配置すると、更新されたサービス ワーカー ファイルがブラウザーによってフェッチされ、更新プロセスが開始されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="9adb5-264">多くの開発者は、この更新が完了しても、ユーザーがすべてのタブでアプリケーションから移動しない限り、この更新が有効に**ならない**ことを意外に思うでしょう。</span><span class="sxs-lookup"><span data-stu-id="9adb5-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="9adb5-265">アプリケーションを 1 つのタブのみに表示している場合でも、アプリケーションを表示しているタブを更新するだけでは十分では**ありません**。</span><span class="sxs-lookup"><span data-stu-id="9adb5-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="9adb5-266">アプリケーションが完全に閉じられるまで、新しいサービス ワーカーは "アクティブ化の待機中" 状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="9adb5-267">**これは Blazor に固有のものではなく、標準的な Web プラットフォームの動作です。**</span><span class="sxs-lookup"><span data-stu-id="9adb5-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="9adb5-268">これは、サービス ワーカーまたはオフラインでキャッシュされたリソースに対する更新をテストしようとしている開発者にとって、共通の問題となります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="9adb5-269">ブラウザーの開発ツールをチェックインすると、次のような内容が表示されることがあります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![イメージ](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="9adb5-271">"クライアント" (つまり、アプリケーションを表示しているタブまたはウィンドウ) のリストが空でない場合、ワーカーは待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="9adb5-272">サービス ワーカーが待機するのは、整合性を保証するためです。つまり、すべてのリソースが同じアトミック キャッシュからフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="9adb5-273">変更をテストする際には、上記のスクリーンショットに示されている "skipWaiting" リンクをクリックし、ページを再度読み込むと便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="9adb5-274">必要に応じて、すべてのユーザーに対してこの動作を自動化できます。そのためには、"待機中" のフェーズをスキップして、[更新時にすぐにアクティブ化](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)するように、サービス ワーカーをコーディングします。</span><span class="sxs-lookup"><span data-stu-id="9adb5-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="9adb5-275">ただし、これを行うと、リソースが常に同じキャッシュ インスタンスから一貫してフェッチされることを保証できなくなります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="9adb5-276">ユーザーはアプリのあらゆる履歴バージョンを実行する可能性がある</span><span class="sxs-lookup"><span data-stu-id="9adb5-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="9adb5-277">Web 開発者は、ユーザーが、配置された最新バージョンの Web アプリケーションを実行するものと思いがちです。これは、従来の Web 配布モデルでは自然なことでした。</span><span class="sxs-lookup"><span data-stu-id="9adb5-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="9adb5-278">ただし、オフラインファーストの PWA は、ユーザーが必ずしも最新バージョンを実行しているとは限らないネイティブ モバイル アプリに似ています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="9adb5-279">「[バックグラウンド更新](#background-updates)」で説明されているように、アプリケーションに更新プログラムを配置すると、**既存の各ユーザーは、少なくともあと 1 回のアクセスで以前のバージョンを使用し続けます** (更新がバックグラウンドで行われ、ユーザーがアプリケーションから移動するまでアクティブ化されないためです)。</span><span class="sxs-lookup"><span data-stu-id="9adb5-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="9adb5-280">また、前回使用されていたバージョンが必ずしも前回に配置したものとは限りません。ユーザーが最後に更新を完了した日時に応じて、*あらゆる*履歴バージョンが使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="9adb5-281">これは、アプリケーションのフロントエンドとバックエンドの部分が API 要求のスキーマに関する合意を必要とする場合に問題になることがあります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="9adb5-282">すべてのユーザーがアップグレードされたことを確認できるまで、または少なくともユーザーが互換性のない古いバージョンのアプリを使用できないようにするまで、下位互換性のない API スキーマの変更を配置することはできません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="9adb5-283">これは、ネイティブ モバイル アプリの場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="9adb5-283">This is just like a native mobile app.</span></span> <span data-ttu-id="9adb5-284">サーバー API に重大な変更を配置すると、まだ更新されていないユーザーに対してクライアント アプリが中断されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="9adb5-285">可能であれば、バックエンド API に重大な変更を配置しないでください。</span><span class="sxs-lookup"><span data-stu-id="9adb5-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="9adb5-286">ただし、この配置を行う必要がある場合は、[`ServiceWorkerRegistration` などの標準のサービス ワーカー API](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) を使用して、アプリケーションが最新であるかどうかを判断し、最新でない場合は使用できないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9adb5-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="9adb5-287">サーバーでレンダリングされるページによる干渉</span><span class="sxs-lookup"><span data-stu-id="9adb5-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="9adb5-288">[前述のように](#support-server-rendered-pages)、すべてのナビゲーション要求に対して `/index.html` コンテンツを返すサービス ワーカーの動作をバイパスする場合は、サービス ワーカーのロジックを編集する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="9adb5-289">サービス ワーカー アセット マニフェストのすべてのコンテンツが既定でキャッシュされる</span><span class="sxs-lookup"><span data-stu-id="9adb5-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="9adb5-290">[前述のように](#control-asset-caching)、ファイル *service-worker-assets.js* はビルド時に生成され、サービス ワーカーでフェッチおよびキャッシュする必要があるすべてのアセットがリストされています。</span><span class="sxs-lookup"><span data-stu-id="9adb5-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="9adb5-291">既定では、このリストには *wwwroot* に出力されるすべての項目 (外部のパッケージとプロジェクトによって提供されるコンテンツを含む) が含まれるので、コンテンツの数が多くなりすぎないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="9adb5-292">たとえば、*wwwroot* ディレクトリに数百万のイメージが含まれている場合、サービス ワーカーによってそれらすべてのフェッチおよびキャッシュが試行され、過剰な帯域幅が消費されて、正常に完了しない可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="9adb5-293">*service-worker.published.js* 内の `onInstall` 関数を編集することで、マニフェストのコンテンツのどのサブセットをフェッチおよびキャッシュするかを制御するために任意のロジックを実装できます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="9adb5-294">認証との相互作用</span><span class="sxs-lookup"><span data-stu-id="9adb5-294">Interaction with authentication</span></span>

<span data-ttu-id="9adb5-295">PWA テンプレート オプションを認証オプションと組み合わせて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="9adb5-296">オフライン対応 PWA では、ユーザーがネットワークに接続しているときに認証をサポートすることもできます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="9adb5-297">ただし、ユーザーがネットワークに接続されていない場合、アクセス トークンを認証したり取得したりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9adb5-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="9adb5-298">既定では、"ログイン" ページにアクセスしようとすると、"ネットワーク エラー" を示すメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9adb5-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="9adb5-299">したがって、ユーザーがアクセス トークンを認証または取得しなくても、オフライン中に有用な作業を実行できるように、または、少なくともこのような場合に適切な形で失敗するように、開発者は UI フローを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9adb5-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="9adb5-300">アプリケーションでこれが不可能な場合は、オフライン サポートを有効にしないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9adb5-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
