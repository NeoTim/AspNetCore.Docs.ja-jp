---
title: ASP.NET Core 内のメモリ内のキャッシュ
author: rick-anderson
description: ASP.NET Core でメモリにデータをキャッシュする方法について説明します。
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 1967fb1942b4003d498800f6cf4c9dd280aca24e
ms.sourcegitcommit: 688b6f448d87b6f7f4440182d72388eaa68d2935
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/14/2020
ms.locfileid: "83393851"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="02e17-103">ASP.NET Core 内のメモリ内のキャッシュ</span><span class="sxs-lookup"><span data-stu-id="02e17-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="02e17-104">[Rick Anderson](https://twitter.com/RickAndMSFT)、 [John luo](https://github.com/JunTaoLuo)、および[上田 Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="02e17-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="02e17-105">[サンプル コードを表示またはダウンロード](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample)します ([ダウンロード方法](xref:index#how-to-download-a-sample))。</span><span class="sxs-lookup"><span data-stu-id="02e17-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="02e17-106">キャッシュの基本</span><span class="sxs-lookup"><span data-stu-id="02e17-106">Caching basics</span></span>

<span data-ttu-id="02e17-107">キャッシュを使用すると、コンテンツを生成するために必要な作業量を減らすことで、アプリのパフォーマンスとスケーラビリティを大幅に向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="02e17-108">キャッシュは、頻繁に変更され **、** 生成に負荷がかかるデータで最適に機能します。</span><span class="sxs-lookup"><span data-stu-id="02e17-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="02e17-109">キャッシュを使用すると、ソースよりもはるかに高速に返されるデータのコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="02e17-110">アプリは、キャッシュされたデータに依存し**ない**ように作成およびテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="02e17-111">ASP.NET Core は、いくつかの異なるキャッシュをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="02e17-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="02e17-112">最も単純なキャッシュは、 [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache)に基づいています。</span><span class="sxs-lookup"><span data-stu-id="02e17-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="02e17-113">`IMemoryCache`web サーバーのメモリに格納されているキャッシュを表します。</span><span class="sxs-lookup"><span data-stu-id="02e17-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="02e17-114">サーバーファーム (複数のサーバー) で実行されているアプリでは、メモリ内キャッシュを使用するときにセッションが固定されていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="02e17-115">固定セッションでは、クライアントからの後続の要求がすべて同じサーバーに送られるようにします。</span><span class="sxs-lookup"><span data-stu-id="02e17-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="02e17-116">たとえば、Azure Web apps では、[アプリケーション要求ルーティング](https://www.iis.net/learn/extensions/planning-for-arr)処理 (ARR) を使用して、後続のすべての要求を同じサーバーにルーティングします。</span><span class="sxs-lookup"><span data-stu-id="02e17-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="02e17-117">Web ファームの固定されていないセッションでは、キャッシュ整合性の問題を回避するために[分散キャッシュ](distributed.md)が必要です。</span><span class="sxs-lookup"><span data-stu-id="02e17-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="02e17-118">アプリによっては、分散キャッシュがメモリ内キャッシュよりも高いスケールアウトをサポートする場合があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="02e17-119">分散キャッシュを使用すると、キャッシュメモリが外部プロセスにオフロードされます。</span><span class="sxs-lookup"><span data-stu-id="02e17-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="02e17-120">メモリ内キャッシュには、任意のオブジェクトを格納できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="02e17-121">分散キャッシュインターフェイスはに制限されてい `byte[]` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="02e17-122">メモリ内および分散キャッシュストアは、キーと値のペアとしてキャッシュ項目を格納します。</span><span class="sxs-lookup"><span data-stu-id="02e17-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="02e17-123">System.string. キャッシュ/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="02e17-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="02e17-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([NuGet パッケージ](https://www.nuget.org/packages/System.Runtime.Caching/)) は、次のものと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="02e17-125">.NET Standard 2.0 以降。</span><span class="sxs-lookup"><span data-stu-id="02e17-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="02e17-126">.NET Standard 2.0 以降を対象とするすべての[.net 実装](/dotnet/standard/net-standard#net-implementation-support)。</span><span class="sxs-lookup"><span data-stu-id="02e17-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="02e17-127">たとえば、2.0 以降の ASP.NET Core ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="02e17-128">.NET Framework 4.5 以降。</span><span class="sxs-lookup"><span data-stu-id="02e17-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="02e17-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` ASP.NET Core に統合することをお勧めします。 `System.Runtime.Caching` / そのため、この記事で説明され `MemoryCache` ているように、このキャッシュはお勧めします。</span><span class="sxs-lookup"><span data-stu-id="02e17-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="02e17-130">たとえば、は `IMemoryCache` ASP.NET Core[依存関係の挿入](xref:fundamentals/dependency-injection)とネイティブに連携します。</span><span class="sxs-lookup"><span data-stu-id="02e17-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="02e17-131">`System.Runtime.Caching` / `MemoryCache` ASP.NET 4.x から ASP.NET Core にコードを移植するときは、互換性ブリッジとして使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="02e17-132">キャッシュのガイドライン</span><span class="sxs-lookup"><span data-stu-id="02e17-132">Cache guidelines</span></span>

* <span data-ttu-id="02e17-133">コードには常に、データをフェッチするためのフォールバックオプションがあり、使用可能なキャッシュ値に依存し**ない**ようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="02e17-134">キャッシュは、不足しているリソース (メモリ) を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="02e17-135">キャッシュ拡張の制限:</span><span class="sxs-lookup"><span data-stu-id="02e17-135">Limit cache growth:</span></span>
  * <span data-ttu-id="02e17-136">外部**入力をキャッシュ**キーとして使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="02e17-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="02e17-137">キャッシュの拡張を制限するには、有効期限を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="02e17-138">[キャッシュサイズを制限するには、SetSize、Size、および SizeLimit を使用](#use-setsize-size-and-sizelimit-to-limit-cache-size)します。</span><span class="sxs-lookup"><span data-stu-id="02e17-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="02e17-139">ASP.NET Core ランタイムでは、メモリ負荷に基づいてキャッシュサイズが制限**されません**。</span><span class="sxs-lookup"><span data-stu-id="02e17-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="02e17-140">キャッシュサイズを制限するのは開発者だけです。</span><span class="sxs-lookup"><span data-stu-id="02e17-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="02e17-141">IMemoryCache を使用する</span><span class="sxs-lookup"><span data-stu-id="02e17-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="02e17-142">[依存関係の挿入](xref:fundamentals/dependency-injection)から*共有*メモリキャッシュを使用し `SetSize` 、、 `Size` 、またはを呼び出して `SizeLimit` キャッシュサイズを制限すると、アプリが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="02e17-143">キャッシュにサイズ制限が設定されている場合、すべてのエントリは追加時にサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="02e17-144">これにより、開発者は共有キャッシュを使用する内容を完全に制御できない場合があるため、問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="02e17-145">たとえば、Entity Framework Core は共有キャッシュを使用し、サイズを指定しません。</span><span class="sxs-lookup"><span data-stu-id="02e17-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="02e17-146">アプリがキャッシュサイズの制限を設定し、EF Core を使用する場合、アプリはをスロー `InvalidOperationException` します。</span><span class="sxs-lookup"><span data-stu-id="02e17-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="02e17-147">、、またはを使用してキャッシュを制限する場合は、キャッシュ `SetSize` `Size` `SizeLimit` 用のキャッシュシングルトンを作成します。</span><span class="sxs-lookup"><span data-stu-id="02e17-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="02e17-148">詳細と例については、「 [SetSize、サイズ、および SizeLimit を使用してキャッシュサイズを制限する](#use-setsize-size-and-sizelimit-to-limit-cache-size)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="02e17-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="02e17-149">共有キャッシュは、他のフレームワークまたはライブラリによって共有されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="02e17-150">たとえば、EF Core は共有キャッシュを使用し、サイズを指定しません。</span><span class="sxs-lookup"><span data-stu-id="02e17-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="02e17-151">インメモリキャッシュは、[依存関係の挿入](xref:fundamentals/dependency-injection)を使用してアプリから参照される*サービス*です。</span><span class="sxs-lookup"><span data-stu-id="02e17-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="02e17-152">`IMemoryCache`コンストラクターにインスタンスを要求します。</span><span class="sxs-lookup"><span data-stu-id="02e17-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="02e17-153">次のコードでは、 [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__)を使用して、時間がキャッシュ内にあるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="02e17-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="02e17-154">時間がキャッシュされていない場合は、新しいエントリが作成され、が[設定](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)されたキャッシュに追加されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="02e17-155">`CacheKeys`クラスは、ダウンロードサンプルに含まれています。</span><span class="sxs-lookup"><span data-stu-id="02e17-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="02e17-156">現在の時刻とキャッシュされた時間が表示されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="02e17-157">キャッシュされた値は、 `DateTime` タイムアウト期間内に要求があってもキャッシュに残ります。</span><span class="sxs-lookup"><span data-stu-id="02e17-157">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="02e17-158">次のコードでは、 [Getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__)と[Getorcreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___)を使用してデータをキャッシュしています。</span><span class="sxs-lookup"><span data-stu-id="02e17-158">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="02e17-159">次のコードは、 [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_)を呼び出して、キャッシュされた時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="02e17-159">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="02e17-160">次のコードは、絶対有効期限があるキャッシュされた項目を取得または作成します。</span><span class="sxs-lookup"><span data-stu-id="02e17-160">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="02e17-161">スライド式有効期限付きのキャッシュされた項目セットは、古くなっている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-161">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="02e17-162">スライディング有効期間よりも頻繁にアクセスされる場合、項目は期限切れになりません。</span><span class="sxs-lookup"><span data-stu-id="02e17-162">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="02e17-163">スライド式有効期限と絶対有効期限を組み合わせて、その絶対有効期限が過ぎると項目が期限切れになることを保証します。</span><span class="sxs-lookup"><span data-stu-id="02e17-163">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="02e17-164">絶対有効期限は、項目をキャッシュできる期間を上限として設定し、スライドしている有効期限の間隔内に項目が要求されていない場合は、前に期限切れになることを許可します。</span><span class="sxs-lookup"><span data-stu-id="02e17-164">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="02e17-165">絶対有効期限とスライド式有効期限の両方を指定した場合、有効期限は論理的に論理和になります。</span><span class="sxs-lookup"><span data-stu-id="02e17-165">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="02e17-166">スライド式有効期限間隔*または*絶対有効期限が経過すると、項目はキャッシュから削除されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-166">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="02e17-167">次のコードは、スライディング*と*絶対の両方の有効期限を持つキャッシュされた項目を取得または作成します。</span><span class="sxs-lookup"><span data-stu-id="02e17-167">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="02e17-168">上記のコードでは、データが絶対時間より長くキャッシュされないことが保証されています。</span><span class="sxs-lookup"><span data-stu-id="02e17-168">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="02e17-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>、 <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> 、および <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> は、クラスの拡張メソッドです <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> 。</span><span class="sxs-lookup"><span data-stu-id="02e17-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="02e17-170">これらのメソッドは、の機能を拡張 <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> します。</span><span class="sxs-lookup"><span data-stu-id="02e17-170">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="02e17-171">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="02e17-171">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="02e17-172">次の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="02e17-172">The following sample:</span></span>

* <span data-ttu-id="02e17-173">スライド式有効期限を設定します。</span><span class="sxs-lookup"><span data-stu-id="02e17-173">Sets a sliding expiration time.</span></span> <span data-ttu-id="02e17-174">このキャッシュされた項目にアクセスする要求は、スライド式有効期限をリセットします。</span><span class="sxs-lookup"><span data-stu-id="02e17-174">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="02e17-175">キャッシュの優先度を[NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove)に設定します。</span><span class="sxs-lookup"><span data-stu-id="02e17-175">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="02e17-176">エントリがキャッシュから削除された後に呼び出される[PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate)を設定します。</span><span class="sxs-lookup"><span data-stu-id="02e17-176">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="02e17-177">コールバックは、キャッシュから項目を削除するコードとは異なるスレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-177">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="02e17-178">SetSize、サイズ、および SizeLimit を使用してキャッシュサイズを制限する</span><span class="sxs-lookup"><span data-stu-id="02e17-178">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="02e17-179">インスタンスでは、 `MemoryCache` 必要に応じてサイズ制限を指定して適用できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-179">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="02e17-180">キャッシュには、エントリのサイズを測定する機構がないため、キャッシュサイズの制限には定義済みの測定単位がありません。</span><span class="sxs-lookup"><span data-stu-id="02e17-180">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="02e17-181">キャッシュサイズの制限が設定されている場合、すべてのエントリでサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-181">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="02e17-182">ASP.NET Core ランタイムでは、メモリ負荷に基づいてキャッシュサイズが制限されません。</span><span class="sxs-lookup"><span data-stu-id="02e17-182">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="02e17-183">キャッシュサイズを制限するのは開発者だけです。</span><span class="sxs-lookup"><span data-stu-id="02e17-183">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="02e17-184">指定されたサイズは、開発者が選択した単位で示されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-184">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="02e17-185">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="02e17-185">For example:</span></span>

* <span data-ttu-id="02e17-186">Web アプリが主に文字列をキャッシュしている場合は、各キャッシュエントリのサイズを文字列の長さにすることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-186">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="02e17-187">アプリでは、すべてのエントリのサイズを1と指定することができ、サイズ制限はエントリの数です。</span><span class="sxs-lookup"><span data-stu-id="02e17-187">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="02e17-188">が <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> 設定されていない場合、キャッシュはバインドされずに拡張されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-188">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="02e17-189">システムメモリが不足している場合、ASP.NET Core ランタイムはキャッシュをトリミングしません。</span><span class="sxs-lookup"><span data-stu-id="02e17-189">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="02e17-190">アプリは次のように設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-190">Apps must be architected to:</span></span>

* <span data-ttu-id="02e17-191">キャッシュの拡張を制限します。</span><span class="sxs-lookup"><span data-stu-id="02e17-191">Limit cache growth.</span></span>
* <span data-ttu-id="02e17-192"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> 使用可能なメモリが制限されている場合、またはを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="02e17-192">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="02e17-193">次のコードでは、 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [依存関係の挿入](xref:fundamentals/dependency-injection)によってアクセス可能な単位固定サイズが作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-193">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="02e17-194">`SizeLimit`に単位がありません。</span><span class="sxs-lookup"><span data-stu-id="02e17-194">`SizeLimit` does not have units.</span></span> <span data-ttu-id="02e17-195">キャッシュサイズの制限が設定されている場合、キャッシュされたエントリは、最適と思われる任意の単位でサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-195">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="02e17-196">キャッシュインスタンスのすべてのユーザーは、同じ単体システムを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-196">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="02e17-197">キャッシュされたエントリサイズの合計がで指定された値を超えた場合、エントリはキャッシュされません `SizeLimit` 。</span><span class="sxs-lookup"><span data-stu-id="02e17-197">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="02e17-198">キャッシュサイズの制限が設定されていない場合、エントリに設定されているキャッシュサイズは無視されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-198">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="02e17-199">次のコードは、 `MyMemoryCache` [依存関係挿入](xref:fundamentals/dependency-injection)コンテナーに登録します。</span><span class="sxs-lookup"><span data-stu-id="02e17-199">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="02e17-200">`MyMemoryCache`は、このサイズ制限付きキャッシュを認識し、キャッシュエントリサイズを適切に設定する方法を理解しているコンポーネントの独立したメモリキャッシュとして作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-200">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="02e17-201">次のコードでは、を使用し `MyMemoryCache` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-201">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="02e17-202">キャッシュエントリのサイズは、または拡張メソッドによって設定でき <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-202">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="02e17-203">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="02e17-203">MemoryCache.Compact</span></span>

<span data-ttu-id="02e17-204">`MemoryCache.Compact`指定された割合のキャッシュを次の順序で削除しようとします:</span><span class="sxs-lookup"><span data-stu-id="02e17-204">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="02e17-205">期限切れのすべての項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-205">All expired items.</span></span>
* <span data-ttu-id="02e17-206">優先順位別の項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-206">Items by priority.</span></span> <span data-ttu-id="02e17-207">優先順位の低い項目が最初に削除されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-207">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="02e17-208">最近使用したオブジェクトのうち、最も古いオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="02e17-208">Least recently used objects.</span></span>
* <span data-ttu-id="02e17-209">最も古い絶対有効期限を持つ項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-209">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="02e17-210">最も古いスライド式有効期限を持つ項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-210">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="02e17-211">優先順位の付いたピン留めされた項目 <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> は削除されません。</span><span class="sxs-lookup"><span data-stu-id="02e17-211">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="02e17-212">次のコードでは、キャッシュ項目を削除し、を呼び出し `Compact` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-212">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="02e17-213">詳細については、 [GitHub の「Compact source](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="02e17-213">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="02e17-214">キャッシュの依存関係</span><span class="sxs-lookup"><span data-stu-id="02e17-214">Cache dependencies</span></span>

<span data-ttu-id="02e17-215">次のサンプルは、依存エントリの有効期限が切れた場合に、キャッシュエントリを期限切れにする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="02e17-215">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="02e17-216"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>がキャッシュされた項目に追加されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-216">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="02e17-217">`Cancel`でが呼び出されると `CancellationTokenSource` 、両方のキャッシュエントリが削除されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-217">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="02e17-218">を使用する <xref:System.Threading.CancellationTokenSource> と、複数のキャッシュエントリを1つのグループとして削除できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-218">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="02e17-219">上記の `using` コードのパターンでは、ブロック内に作成されたキャッシュエントリによって、 `using` トリガーと有効期限の設定が継承されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-219">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="02e17-220">その他のメモ</span><span class="sxs-lookup"><span data-stu-id="02e17-220">Additional notes</span></span>

* <span data-ttu-id="02e17-221">有効期限はバックグラウンドでは発生しません。</span><span class="sxs-lookup"><span data-stu-id="02e17-221">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="02e17-222">期限切れの項目のキャッシュをアクティブにスキャンするタイマーはありません。</span><span class="sxs-lookup"><span data-stu-id="02e17-222">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="02e17-223">キャッシュ (、、) のすべてのアクティビティ `Get` `Set` は、 `Remove` 期限切れの項目に対してバックグラウンドスキャンをトリガーできます。</span><span class="sxs-lookup"><span data-stu-id="02e17-223">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="02e17-224">() のタイマーによって、 `CancellationTokenSource` <xref:System.Threading.CancellationTokenSource.CancelAfter*> エントリも削除され、期限切れの項目のスキャンがトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="02e17-224">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="02e17-225">次の例では、登録されたトークンに[CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor)を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-225">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="02e17-226">このトークンが起動すると、エントリが直ちに削除され、削除コールバックが発生します。</span><span class="sxs-lookup"><span data-stu-id="02e17-226">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="02e17-227">コールバックを使用してキャッシュ項目を再作成する場合:</span><span class="sxs-lookup"><span data-stu-id="02e17-227">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="02e17-228">コールバックが完了していないため、複数の要求でキャッシュされたキー値を空にすることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-228">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="02e17-229">これにより、複数のスレッドがキャッシュされた項目を再作成する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-229">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="02e17-230">あるキャッシュエントリを使用して別のキャッシュエントリを作成すると、子は親エントリの有効期限トークンと時間ベースの有効期限の設定をコピーします。</span><span class="sxs-lookup"><span data-stu-id="02e17-230">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="02e17-231">親エントリを手動で削除または更新しても、子の有効期限は切れません。</span><span class="sxs-lookup"><span data-stu-id="02e17-231">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="02e17-232">キャッシュ <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> からキャッシュエントリが削除された後に起動されるコールバックを設定するには、を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="02e17-233">ほとんどのアプリで `IMemoryCache` は、が有効になっています。</span><span class="sxs-lookup"><span data-stu-id="02e17-233">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="02e17-234">たとえば、、、 `AddMvc` `AddControllersWithViews` `AddRazorPages` 、 `AddMvcCore().AddRazorViewEngine` 、およびの他の多くのメソッドを呼び出すと、 `Add{Service}` `ConfigureServices` が有効になり `IMemoryCache` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-234">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="02e17-235">上記のメソッドのいずれかを呼び出さないアプリでは `Add{Service}` 、でを呼び出す必要がある場合があり <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> `ConfigureServices` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-235">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="02e17-236">バックグラウンドキャッシュ更新</span><span class="sxs-lookup"><span data-stu-id="02e17-236">Background cache update</span></span>

<span data-ttu-id="02e17-237">などの[バックグラウンドサービス](xref:fundamentals/host/hosted-services)を使用して <xref:Microsoft.Extensions.Hosting.IHostedService> キャッシュを更新します。</span><span class="sxs-lookup"><span data-stu-id="02e17-237">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="02e17-238">バックグラウンドサービスでは、エントリを再計算して、準備ができたときにのみキャッシュに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-238">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="02e17-239">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="02e17-239">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="02e17-240">[Rick Anderson](https://twitter.com/RickAndMSFT)、 [John luo](https://github.com/JunTaoLuo)、および[上田 Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="02e17-240">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="02e17-241">[サンプル コードを表示またはダウンロード](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample)します ([ダウンロード方法](xref:index#how-to-download-a-sample))。</span><span class="sxs-lookup"><span data-stu-id="02e17-241">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="02e17-242">キャッシュの基本</span><span class="sxs-lookup"><span data-stu-id="02e17-242">Caching basics</span></span>

<span data-ttu-id="02e17-243">キャッシュを使用すると、コンテンツを生成するために必要な作業量を減らすことで、アプリのパフォーマンスとスケーラビリティを大幅に向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-243">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="02e17-244">キャッシュは、あまり変更されないデータで最適に機能します。</span><span class="sxs-lookup"><span data-stu-id="02e17-244">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="02e17-245">キャッシュを使用すると、元のソースよりもはるかに高速に返されるデータのコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-245">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="02e17-246">コードは、キャッシュされたデータに依存し**ない**ように記述してテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-246">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="02e17-247">ASP.NET Core は、いくつかの異なるキャッシュをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="02e17-247">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="02e17-248">最も単純なキャッシュは、web サーバーのメモリに格納されているキャッシュを表す[IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache)に基づいています。</span><span class="sxs-lookup"><span data-stu-id="02e17-248">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="02e17-249">サーバーファーム (複数のサーバー) で実行されるアプリでは、メモリ内キャッシュを使用するときにセッションが固定されていることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-249">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="02e17-250">固定セッションでは、クライアントからの以降の要求がすべて同じサーバーに送られるようにします。</span><span class="sxs-lookup"><span data-stu-id="02e17-250">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="02e17-251">たとえば、Azure Web apps は、[アプリケーション要求ルーティング](https://www.iis.net/learn/extensions/planning-for-arr)処理 (ARR) を使用して、ユーザーエージェントからのすべての要求を同じサーバーにルーティングします。</span><span class="sxs-lookup"><span data-stu-id="02e17-251">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="02e17-252">Web ファームの固定されていないセッションでは、キャッシュ整合性の問題を回避するために[分散キャッシュ](distributed.md)が必要です。</span><span class="sxs-lookup"><span data-stu-id="02e17-252">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="02e17-253">アプリによっては、分散キャッシュがメモリ内キャッシュよりも高いスケールアウトをサポートする場合があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-253">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="02e17-254">分散キャッシュを使用すると、キャッシュメモリが外部プロセスにオフロードされます。</span><span class="sxs-lookup"><span data-stu-id="02e17-254">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="02e17-255">メモリ内キャッシュには、任意のオブジェクトを格納できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-255">The in-memory cache can store any object.</span></span> <span data-ttu-id="02e17-256">分散キャッシュインターフェイスはに制限されてい `byte[]` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-256">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="02e17-257">メモリ内および分散キャッシュストアは、キーと値のペアとしてキャッシュ項目を格納します。</span><span class="sxs-lookup"><span data-stu-id="02e17-257">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="02e17-258">System.string. キャッシュ/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="02e17-258">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="02e17-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([NuGet パッケージ](https://www.nuget.org/packages/System.Runtime.Caching/)) は、次のものと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="02e17-260">.NET Standard 2.0 以降。</span><span class="sxs-lookup"><span data-stu-id="02e17-260">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="02e17-261">.NET Standard 2.0 以降を対象とするすべての[.net 実装](/dotnet/standard/net-standard#net-implementation-support)。</span><span class="sxs-lookup"><span data-stu-id="02e17-261">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="02e17-262">たとえば、2.0 以降の ASP.NET Core ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-262">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="02e17-263">.NET Framework 4.5 以降。</span><span class="sxs-lookup"><span data-stu-id="02e17-263">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="02e17-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` ASP.NET Core に統合することをお勧めします。 `System.Runtime.Caching` / そのため、この記事で説明され `MemoryCache` ているように、このキャッシュはお勧めします。</span><span class="sxs-lookup"><span data-stu-id="02e17-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="02e17-265">たとえば、は `IMemoryCache` ASP.NET Core[依存関係の挿入](xref:fundamentals/dependency-injection)とネイティブに連携します。</span><span class="sxs-lookup"><span data-stu-id="02e17-265">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="02e17-266">`System.Runtime.Caching` / `MemoryCache` ASP.NET 4.x から ASP.NET Core にコードを移植するときは、互換性ブリッジとして使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-266">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="02e17-267">キャッシュのガイドライン</span><span class="sxs-lookup"><span data-stu-id="02e17-267">Cache guidelines</span></span>

* <span data-ttu-id="02e17-268">コードには常に、データをフェッチするためのフォールバックオプションがあり、使用可能なキャッシュ値に依存し**ない**ようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-268">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="02e17-269">キャッシュは、不足しているリソース (メモリ) を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-269">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="02e17-270">キャッシュ拡張の制限:</span><span class="sxs-lookup"><span data-stu-id="02e17-270">Limit cache growth:</span></span>
  * <span data-ttu-id="02e17-271">外部**入力をキャッシュ**キーとして使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="02e17-271">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="02e17-272">キャッシュの拡張を制限するには、有効期限を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-272">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="02e17-273">[キャッシュサイズを制限するには、SetSize、Size、および SizeLimit を使用](#use-setsize-size-and-sizelimit-to-limit-cache-size)します。</span><span class="sxs-lookup"><span data-stu-id="02e17-273">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="02e17-274">ASP.NET Core ランタイムでは、メモリ負荷に基づいてキャッシュサイズが制限されません。</span><span class="sxs-lookup"><span data-stu-id="02e17-274">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="02e17-275">キャッシュサイズを制限するのは開発者だけです。</span><span class="sxs-lookup"><span data-stu-id="02e17-275">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="02e17-276">IMemoryCache の使用</span><span class="sxs-lookup"><span data-stu-id="02e17-276">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="02e17-277">[依存関係の挿入](xref:fundamentals/dependency-injection)から*共有*メモリキャッシュを使用し `SetSize` 、、 `Size` 、またはを呼び出して `SizeLimit` キャッシュサイズを制限すると、アプリが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-277">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="02e17-278">キャッシュにサイズ制限が設定されている場合、すべてのエントリは追加時にサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-278">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="02e17-279">これにより、開発者は共有キャッシュを使用する内容を完全に制御できない場合があるため、問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-279">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="02e17-280">たとえば、Entity Framework Core は共有キャッシュを使用し、サイズを指定しません。</span><span class="sxs-lookup"><span data-stu-id="02e17-280">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="02e17-281">アプリがキャッシュサイズの制限を設定し、EF Core を使用する場合、アプリはをスロー `InvalidOperationException` します。</span><span class="sxs-lookup"><span data-stu-id="02e17-281">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="02e17-282">、、またはを使用してキャッシュを制限する場合は、キャッシュ `SetSize` `Size` `SizeLimit` 用のキャッシュシングルトンを作成します。</span><span class="sxs-lookup"><span data-stu-id="02e17-282">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="02e17-283">詳細と例については、「 [SetSize、サイズ、および SizeLimit を使用してキャッシュサイズを制限する](#use-setsize-size-and-sizelimit-to-limit-cache-size)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="02e17-283">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="02e17-284">インメモリキャッシュは、[依存関係の挿入](../../fundamentals/dependency-injection.md)を使用してアプリから参照される*サービス*です。</span><span class="sxs-lookup"><span data-stu-id="02e17-284">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="02e17-285">`AddMemoryCache`での呼び出し `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="02e17-285">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="02e17-286">`IMemoryCache`コンストラクターにインスタンスを要求します。</span><span class="sxs-lookup"><span data-stu-id="02e17-286">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="02e17-287">`IMemoryCache`では、 [AspNetCore メタパッケージ](xref:fundamentals/metapackage-app)で入手できる NuGet パッケージ[microsoft. extension. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)が必要です。</span><span class="sxs-lookup"><span data-stu-id="02e17-287">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="02e17-288">次のコードでは、 [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__)を使用して、時間がキャッシュ内にあるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="02e17-288">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="02e17-289">時間がキャッシュされていない場合は、新しいエントリが作成され、が[設定](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)されたキャッシュに追加されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-289">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="02e17-290">現在の時刻とキャッシュされた時間が表示されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-290">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="02e17-291">キャッシュされた値は、 `DateTime` タイムアウト期間内に要求があってもキャッシュに残ります。</span><span class="sxs-lookup"><span data-stu-id="02e17-291">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="02e17-292">次の図は、現在の時刻と、キャッシュから取得された古い時間を示しています。</span><span class="sxs-lookup"><span data-stu-id="02e17-292">The following image shows the current time and an older time retrieved from the cache:</span></span>

![2つの異なる時刻が表示されたインデックスビュー](memory/_static/time.png)

<span data-ttu-id="02e17-294">次のコードでは、 [Getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__)と[Getorcreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___)を使用してデータをキャッシュしています。</span><span class="sxs-lookup"><span data-stu-id="02e17-294">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="02e17-295">次のコードは、 [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_)を呼び出して、キャッシュされた時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="02e17-295">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="02e17-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>、 <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> 、および[Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_)は、の機能を拡張する[cacheextensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions)クラスの拡張メソッドです <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> 。</span><span class="sxs-lookup"><span data-stu-id="02e17-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="02e17-297">他のキャッシュメソッドの詳細については、「 [IMemoryCache メソッド](/dotnet/api/microsoft.extensions.caching.memory.imemorycache)と[cacheextensions メソッド](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="02e17-297">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="02e17-298">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="02e17-298">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="02e17-299">次の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="02e17-299">The following sample:</span></span>

* <span data-ttu-id="02e17-300">スライド式有効期限を設定します。</span><span class="sxs-lookup"><span data-stu-id="02e17-300">Sets a sliding expiration time.</span></span> <span data-ttu-id="02e17-301">このキャッシュされた項目にアクセスする要求は、スライド式有効期限をリセットします。</span><span class="sxs-lookup"><span data-stu-id="02e17-301">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="02e17-302">キャッシュの優先順位をに設定し `CacheItemPriority.NeverRemove` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-302">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="02e17-303">エントリがキャッシュから削除された後に呼び出される[PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate)を設定します。</span><span class="sxs-lookup"><span data-stu-id="02e17-303">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="02e17-304">コールバックは、キャッシュから項目を削除するコードとは異なるスレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-304">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="02e17-305">SetSize、サイズ、および SizeLimit を使用してキャッシュサイズを制限する</span><span class="sxs-lookup"><span data-stu-id="02e17-305">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="02e17-306">インスタンスでは、 `MemoryCache` 必要に応じてサイズ制限を指定して適用できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-306">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="02e17-307">キャッシュには、エントリのサイズを測定する機構がないため、キャッシュサイズの制限には定義済みの測定単位がありません。</span><span class="sxs-lookup"><span data-stu-id="02e17-307">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="02e17-308">キャッシュサイズの制限が設定されている場合、すべてのエントリでサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-308">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="02e17-309">ASP.NET Core ランタイムでは、メモリ負荷に基づいてキャッシュサイズが制限されません。</span><span class="sxs-lookup"><span data-stu-id="02e17-309">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="02e17-310">キャッシュサイズを制限するのは開発者だけです。</span><span class="sxs-lookup"><span data-stu-id="02e17-310">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="02e17-311">指定されたサイズは、開発者が選択した単位で示されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-311">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="02e17-312">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="02e17-312">For example:</span></span>

* <span data-ttu-id="02e17-313">Web アプリが主に文字列をキャッシュしている場合は、各キャッシュエントリのサイズを文字列の長さにすることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-313">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="02e17-314">アプリでは、すべてのエントリのサイズを1と指定することができ、サイズ制限はエントリの数です。</span><span class="sxs-lookup"><span data-stu-id="02e17-314">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="02e17-315"><xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit>が設定されていない場合、キャッシュはバインドされずに拡張されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-315">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="02e17-316">ASP.NET Core ランタイムは、システムメモリが不足しているとキャッシュをトリミングしません。</span><span class="sxs-lookup"><span data-stu-id="02e17-316">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="02e17-317">アプリは次のように設計されています。</span><span class="sxs-lookup"><span data-stu-id="02e17-317">Apps much be architected to:</span></span>

* <span data-ttu-id="02e17-318">キャッシュの拡張を制限します。</span><span class="sxs-lookup"><span data-stu-id="02e17-318">Limit cache growth.</span></span>
* <span data-ttu-id="02e17-319"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> 使用可能なメモリが制限されている場合、またはを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="02e17-319">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="02e17-320">次のコードでは、 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [依存関係の挿入](xref:fundamentals/dependency-injection)によってアクセス可能な単位固定サイズが作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-320">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="02e17-321">`SizeLimit`に単位がありません。</span><span class="sxs-lookup"><span data-stu-id="02e17-321">`SizeLimit` does not have units.</span></span> <span data-ttu-id="02e17-322">キャッシュサイズの制限が設定されている場合、キャッシュされたエントリは、最適と思われる任意の単位でサイズを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-322">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="02e17-323">キャッシュインスタンスのすべてのユーザーは、同じ単体システムを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-323">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="02e17-324">キャッシュされたエントリサイズの合計がで指定された値を超えた場合、エントリはキャッシュされません `SizeLimit` 。</span><span class="sxs-lookup"><span data-stu-id="02e17-324">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="02e17-325">キャッシュサイズの制限が設定されていない場合、エントリに設定されているキャッシュサイズは無視されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-325">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="02e17-326">次のコードは、 `MyMemoryCache` [依存関係挿入](xref:fundamentals/dependency-injection)コンテナーに登録します。</span><span class="sxs-lookup"><span data-stu-id="02e17-326">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="02e17-327">`MyMemoryCache`は、このサイズ制限付きキャッシュを認識し、キャッシュエントリサイズを適切に設定する方法を理解しているコンポーネントの独立したメモリキャッシュとして作成されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-327">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="02e17-328">次のコードでは、を使用し `MyMemoryCache` ます。</span><span class="sxs-lookup"><span data-stu-id="02e17-328">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="02e17-329">キャッシュエントリのサイズは、 [size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size)または[SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_)拡張メソッドを使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-329">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="02e17-330">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="02e17-330">MemoryCache.Compact</span></span>

<span data-ttu-id="02e17-331">`MemoryCache.Compact`指定された割合のキャッシュを次の順序で削除しようとします:</span><span class="sxs-lookup"><span data-stu-id="02e17-331">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="02e17-332">期限切れのすべての項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-332">All expired items.</span></span>
* <span data-ttu-id="02e17-333">優先順位別の項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-333">Items by priority.</span></span> <span data-ttu-id="02e17-334">優先順位の低い項目が最初に削除されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-334">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="02e17-335">最近使用したオブジェクトのうち、最も古いオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="02e17-335">Least recently used objects.</span></span>
* <span data-ttu-id="02e17-336">最も古い絶対有効期限を持つ項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-336">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="02e17-337">最も古いスライド式有効期限を持つ項目。</span><span class="sxs-lookup"><span data-stu-id="02e17-337">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="02e17-338">優先順位の付いたピン留めされた項目 <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> は削除されません。</span><span class="sxs-lookup"><span data-stu-id="02e17-338">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="02e17-339">詳細については、 [GitHub の「Compact source](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="02e17-339">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="02e17-340">キャッシュの依存関係</span><span class="sxs-lookup"><span data-stu-id="02e17-340">Cache dependencies</span></span>

<span data-ttu-id="02e17-341">次のサンプルは、依存エントリの有効期限が切れた場合に、キャッシュエントリを期限切れにする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="02e17-341">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="02e17-342"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>がキャッシュされた項目に追加されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-342">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="02e17-343">`Cancel`でが呼び出されると `CancellationTokenSource` 、両方のキャッシュエントリが削除されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-343">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="02e17-344">を使用する `CancellationTokenSource` と、複数のキャッシュエントリを1つのグループとして削除できます。</span><span class="sxs-lookup"><span data-stu-id="02e17-344">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="02e17-345">上記の `using` コードのパターンでは、ブロック内に作成されたキャッシュエントリによって、 `using` トリガーと有効期限の設定が継承されます。</span><span class="sxs-lookup"><span data-stu-id="02e17-345">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="02e17-346">その他のメモ</span><span class="sxs-lookup"><span data-stu-id="02e17-346">Additional notes</span></span>

* <span data-ttu-id="02e17-347">コールバックを使用してキャッシュ項目を再作成する場合:</span><span class="sxs-lookup"><span data-stu-id="02e17-347">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="02e17-348">コールバックが完了していないため、複数の要求でキャッシュされたキー値を空にすることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-348">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="02e17-349">これにより、複数のスレッドがキャッシュされた項目を再作成する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02e17-349">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="02e17-350">あるキャッシュエントリを使用して別のキャッシュエントリを作成すると、子は親エントリの有効期限トークンと時間ベースの有効期限の設定をコピーします。</span><span class="sxs-lookup"><span data-stu-id="02e17-350">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="02e17-351">親エントリを手動で削除または更新しても、子の有効期限は切れません。</span><span class="sxs-lookup"><span data-stu-id="02e17-351">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="02e17-352">キャッシュからキャッシュエントリが削除された後に起動されるコールバックを設定するには、 [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks)を使用します。</span><span class="sxs-lookup"><span data-stu-id="02e17-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="02e17-353">バックグラウンドキャッシュ更新</span><span class="sxs-lookup"><span data-stu-id="02e17-353">Background cache update</span></span>

<span data-ttu-id="02e17-354">などの[バックグラウンドサービス](xref:fundamentals/host/hosted-services)を使用して <xref:Microsoft.Extensions.Hosting.IHostedService> キャッシュを更新します。</span><span class="sxs-lookup"><span data-stu-id="02e17-354">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="02e17-355">バックグラウンドサービスでは、エントリを再計算して、準備ができたときにのみキャッシュに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="02e17-355">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="02e17-356">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="02e17-356">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
